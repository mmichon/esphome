esphome:
  name: trmnl
  friendly_name: trmnl
  on_boot:
    priority: 600
    then:
      - output.turn_on: bsp_battery_enable
      - delay: 200ms
      - component.update: battery_voltage
      - component.update: battery_level
      # Initialize refresh cycle
      - lambda: |-
          setCpuFrequencyMhz(160);  // Start at lower frequency, boost only for display update
          id(initial_data_loaded) = false;
          id(cycle_update_done) = false;
          id(update_start_millis) = millis();
          id(display_update_pending) = true;
          id(sensor_retry_count) = 0;
          id(last_retry_millis) = 0;
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.lights_on
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: climate.infinitive
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: cover.garage_door_2
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: lock.garage_lock
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: binary_sensor.upstairs_entry_contact
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: binary_sensor.wifi_door_3
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: binary_sensor.wyzesense_patio_door
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: binary_sensor.garage_entry_contact
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.147_123_1min
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.estimated_monthly_cost
      # Calendar events and banner text removed from boot fetch - use cached values
      # These update automatically via Home Assistant API when they change, saving 3 API calls per wake
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.0xa4c138ad595857b4_moisture
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.0xa4c138a2694c85eb_moisture
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.0xa4c13840446557e9_moisture
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.0xa4c138f2326a9968_moisture
      # Initial render will wait for HA data via sensor callbacks below

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino
  # Use custom partition table with increased NVS size
  partitions: /Users/mmichon/src/147-esphome/custom_partitions.csv

# Enable logging - minimal level for battery optimization
logger:
  level: WARN  # WARN for minimal power consumption
  logs:
    esphome: WARN
    main: WARN

# Configure preferences to reduce flash writes
preferences:
  flash_write_interval: 1h  # Only write to flash once per hour max

# Enable Home Assistant API
api:
  id: api_server
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome

deep_sleep:
  id: managed_sleep
  sleep_duration: 30min
  wakeup_pin:
    number: GPIO0
    mode: INPUT_PULLUP
    inverted: true
  wakeup_pin_mode: KEEP_AWAKE

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none  # Disable power save for faster connection, then sleep immediately
  fast_connect: true
  reboot_timeout: 2min  # Reduced from 5min to fail faster and sleep sooner
  # Removed redundant on_connect entity fetches - boot sequence already fetches all entities
  # This saves 17 API calls per wake cycle since WiFi connects fresh each time from deep sleep

captive_portal:

spi:
  clk_pin: GPIO7
  mosi_pin: GPIO9

# Fonts - Using local fonts to avoid network issues
font:
  - file: "fonts/GoogleSans-Bold.ttf"
    id: small_font
    size: 24
    glyphs: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~•"
  - file: "fonts/GoogleSans-Bold.ttf"
    id: tiny_font
    size: 18
    glyphs: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~•"
  - file: "fonts/GoogleSans-Bold.ttf"
    id: mid_font
    size: 36
    glyphs: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~•"
  - file: "fonts/GoogleSans-Bold.ttf"
    id: status_font
    size: 30
    glyphs: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~•"
  - file: "fonts/GoogleSans-Bold.ttf"
    id: power_font
    size: 30
    glyphs: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~•"
  - file: "fonts/GoogleSans-Bold.ttf"
    id: big_font
    size: 135
    glyphs: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~•"
  - file: "fonts/GoogleSans-Bold.ttf"
    id: large_font
    size: 54
    glyphs: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~•"
  - file: "fonts/GoogleSans-Bold.ttf"
    id: date_font
    size: 43
    glyphs: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~•"
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: font_bat_icon
    size: 24
    glyphs:
      - "\U000F007A" # mdi-battery-10
      - "\U000F007B" # mdi-battery-20
      - "\U000F007C" # mdi-battery-30
      - "\U000F007D" # mdi-battery-40
      - "\U000F007E" # mdi-battery-50
      - "\U000F007F" # mdi-battery-60
      - "\U000F0080" # mdi-battery-70
      - "\U000F0081" # mdi-battery-80
      - "\U000F0082" # mdi-battery-90
      - "\U000F0079" # mdi-battery
      - "\U000F0084" # mdi-battery-100 (full battery)
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: door_icon_font
    size: 48
    glyphs:
      - "\U000F02D8" # garage
      - "\U000F11B8" # door-open
      - "\U000F01D7" # door-closed
      - "\U000F033E" # lock
      - "\U000F033F" # lock-open
      - "\U000F002F" # alert
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: alarm_status_font
    size: 24
    glyphs:
      - "\U000F033E" # lock (armed)
      - "\U000F033F" # lock-open (disarmed)
      - "\U000F002F" # alert (unknown/error)
  - file: "fonts/MaterialIcons-Regular.ttf"
    id: guest_icon_font
    size: 104
    glyphs:
      - "\U0000e16b" # weekend (overnight guest mode) - Google Material Icons
  - file: "fonts/MaterialIcons-Regular.ttf"
    id: package_icon_font
    size: 104
    glyphs:
      - "\U0000e3d1" # inventory_2 (package detected) - Google Material Icons
  - file: "fonts/MaterialIcons-Regular.ttf"
    id: trash_icon_font
    size: 104
    glyphs:
      - "\U0000ea4c" # auto_delete (trash night) - Google Material Icons
  - file: "fonts/MaterialIcons-Regular.ttf"
    id: alarm_icon_font
    size: 104
    glyphs:
      - "\U0000e867" # shield_lock (alarm armed) - Google Material Icons
      - "\U0000e898" # lock_open (disarmed) - Google Material Icons
      - "\U0000e875" # door_open (open door) - Google Material Icons
      - "\U0000e0ef" # lightbulb - Google Material Icons
      - "\U0000e88a" # potted_plant (dry plant) - Google Material Icons

globals:
  - id: battery_glyph
    type: std::string
    restore_value: no
    initial_value: R"(\U000F0079)"
  - id: alarm_status_glyph
    type: std::string
    restore_value: no
    initial_value: R"(\U000F002F)"  # alert (unknown)
  - id: initial_data_loaded
    type: bool
    restore_value: no
    initial_value: "false"
  - id: power_stats
    type: float[2]
    restore_value: no
    initial_value: "{0.0f, -1.0f}"
  - id: power_stats_day
    type: int
    restore_value: no
    initial_value: "-1"
  - id: power_stats_initialized
    type: bool
    restore_value: no
    initial_value: "false"
  - id: display_update_pending
    type: bool
    restore_value: no
    initial_value: "false"
  - id: cycle_update_done
    type: bool
    restore_value: no
    initial_value: "false"
  - id: package_detected
    type: bool
    restore_value: no
    initial_value: "false"
  - id: update_start_millis
    type: uint32_t
    restore_value: no
    initial_value: "0"
  - id: last_update_time
    type: std::string
    restore_value: no
    initial_value: ""
  - id: peak_power_time
    type: std::string
    restore_value: no
    initial_value: ""
  - id: sensor_retry_count
    type: int
    restore_value: no
    initial_value: "0"
  - id: last_retry_millis
    type: uint32_t
    restore_value: no
    initial_value: "0"
  - id: last_known_power
    type: float
    restore_value: yes
    initial_value: "NAN"
  - id: last_known_cost
    type: float
    restore_value: yes
    initial_value: "NAN"
  - id: last_known_lights
    type: float
    restore_value: yes
    initial_value: "NAN"
  - id: last_known_event_name
    type: std::string
    restore_value: no
    initial_value: ""
  - id: last_known_event_time
    type: std::string
    restore_value: no
    initial_value: ""

script:
  - id: queue_display_refresh
    mode: restart
    then:
      - lambda: |-
          // Prevent display updates between midnight and 7am to conserve power
          auto current_time = id(ha_time).now();
          if (current_time.is_valid()) {
            int current_hour = current_time.hour;
            if (current_hour >= 0 && current_hour < 7) {
              return;
            }
          }
          id(update_start_millis) = millis();
          id(display_update_pending) = true;
          id(cycle_update_done) = false;
  - id: retry_sensor_fetch
    mode: restart
    then:
      - lambda: |-
          id(sensor_retry_count)++;
          id(last_retry_millis) = millis();
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.lights_on
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: climate.infinitive
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: cover.garage_door_2
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: lock.garage_lock
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: binary_sensor.upstairs_entry_contact
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: binary_sensor.wifi_door_3
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: binary_sensor.wyzesense_patio_door
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: binary_sensor.garage_entry_contact
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.147_123_1min
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.estimated_monthly_cost
      # Calendar events and banner text removed from retry fetch - use cached values
      # These update automatically via Home Assistant API when they change, saving 3 API calls per retry
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.0xa4c138ad595857b4_moisture
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.0xa4c138a2694c85eb_moisture
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.0xa4c13840446557e9_moisture
      - homeassistant.service:
          service: homeassistant.update_entity
          data:
            entity_id: sensor.0xa4c138f2326a9968_moisture
  - id: delayed_deep_sleep
    mode: restart
    then:
      - delay: 100ms  # Reduced from 200ms to sleep sooner
      - lambda: |-
          // Lower CPU frequency before sleep to reduce power consumption
          setCpuFrequencyMhz(80);
          // Preferences are automatically saved by ESPHome when they change
          // The flash_write_interval controls how frequently they're written to flash
          id(managed_sleep).begin_sleep(true);

sensor:
  - platform: adc
    pin: GPIO1
    name: "Battery Voltage"
    id: battery_voltage
    attenuation: 12db
    filters:
      - multiply: 2.0
    # Sample every 5 minutes for battery telemetry to reduce power
    update_interval: 5min
  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    icon: "mdi:battery"
    device_class: battery
    state_class: measurement
    lambda: "return id(battery_voltage).state;"
    filters:
      - calibrate_linear:
          - 4.15 -> 100.0
          - 3.96 -> 90.0
          - 3.91 -> 80.0
          - 3.85 -> 70.0
          - 3.80 -> 60.0
          - 3.75 -> 50.0
          - 3.68 -> 40.0
          - 3.58 -> 30.0
          - 3.49 -> 20.0
          - 3.41 -> 10.0
          - 3.30 -> 5.0
          - 3.27 -> 0.0
      - clamp:
          min_value: 0
          max_value: 100
    on_value:
      then:
        - lambda: |-
            float level = x;
            if (level >= 100) {
              id(battery_glyph) = "\U000F0084"; // mdi-battery-100 (full battery)
            } else if (level >= 90) {
              id(battery_glyph) = "\U000F0082"; // mdi-battery-90
            } else if (level >= 80) {
              id(battery_glyph) = "\U000F0081"; // mdi-battery-80
            } else if (level >= 70) {
              id(battery_glyph) = "\U000F0080"; // mdi-battery-70
            } else if (level >= 60) {
              id(battery_glyph) = "\U000F007F"; // mdi-battery-60
            } else if (level >= 50) {
              id(battery_glyph) = "\U000F007E"; // mdi-battery-50
            } else if (level >= 40) {
              id(battery_glyph) = "\U000F007D"; // mdi-battery-40
            } else if (level >= 30) {
              id(battery_glyph) = "\U000F007C"; // mdi-battery-30
            } else if (level >= 20) {
              id(battery_glyph) = "\U000F007B"; // mdi-battery-20
            } else if (level >= 10) {
              id(battery_glyph) = "\U000F007A"; // mdi-battery-10
            } else {
              id(battery_glyph) = "\U000F0079"; // mdi-battery (empty)
            }
  - platform: homeassistant
    id: lights_on
    entity_id: sensor.lights_on
    on_value:
      then:
        - lambda: |-
            // Only update last known value if we got a valid number (not NAN)
            if (!isnan(x) && x >= 0.0f) {
              id(last_known_lights) = x;
            }

            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: indoor_temp
    entity_id: climate.infinitive
    attribute: current_temperature
    on_value:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: furnace_setting
    entity_id: climate.infinitive
    attribute: temperature
  - platform: homeassistant
    id: plant1_moisture
    entity_id: sensor.0xa4c138ad595857b4_moisture
    on_value:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: plant2_moisture
    entity_id: sensor.0xa4c138a2694c85eb_moisture
    on_value:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: plant3_moisture
    entity_id: sensor.0xa4c13840446557e9_moisture
    on_value:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: plant4_moisture
    entity_id: sensor.0xa4c138f2326a9968_moisture
    on_value:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: template
    name: "Daily Power Min"
    id: daily_power_min
    unit_of_measurement: "W"
    accuracy_decimals: 1
    state_class: measurement
    lambda: |-
      if (id(power_stats)[1] < 0.0f) {
        return NAN;
      }
      return id(power_stats)[1];
    update_interval: never
  - platform: template
    name: "Daily Power Max"
    id: daily_power_max
    unit_of_measurement: "W"
    accuracy_decimals: 1
    state_class: measurement
    lambda: |-
      if (id(power_stats)[0] <= 0.0f) {
        return NAN;
      }
      return id(power_stats)[0];
    update_interval: never

output:
  - platform: gpio
    pin: GPIO6
    id: bsp_battery_enable

button:
  - platform: factory_reset
    name: "Factory Reset"
    id: factory_reset_button
    entity_category: config

binary_sensor:
  - platform: homeassistant
    id: entry_door
    entity_id: binary_sensor.upstairs_entry_contact
    on_state:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: upstairs_patio_door
    entity_id: binary_sensor.wifi_door_3
    on_state:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: inlaw_door
    entity_id: binary_sensor.wyzesense_patio_door
    on_state:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  # Removed duplicate inlaw_patio_door sensor - it uses the same entity as inlaw_door
  # Display code now uses inlaw_door for both "In-law" and "In-law Patio" status
  - platform: homeassistant
    id: garage_entry_door
    entity_id: binary_sensor.garage_entry_contact
    on_state:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: guest_mode
    entity_id: input_boolean.guest_mode
    on_state:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: debug_mode
    entity_id: input_boolean.trmnl_debug_mode
    on_state:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: package_sensor
    entity_id: input_boolean.package_detected
    on_state:
      then:
        - lambda: |-
            id(package_detected) = x;
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
# Home Assistant time
time:
  - platform: homeassistant
    id: ha_time

# Timeout fallback to prevent infinite loading
# Adaptive polling: shorter interval when pending, longer when idle
interval:
  - interval: 8s  # Increased from 5s to reduce power consumption during wake cycles
    then:
      - lambda: |-
          const uint32_t now_ms = millis();
          bool has_lights = id(lights_on).has_state();
          bool has_indoor_temp = id(indoor_temp).has_state();
          bool has_power = id(current_power_usage).has_state();
          bool has_guest_mode = id(guest_mode).has_state();
          bool has_garage_lock = id(garage_lock).has_state();
          bool has_garage_door = id(garage_door).has_state();

          bool all_data_ready = has_lights && has_indoor_temp && has_power && has_guest_mode && has_garage_lock && has_garage_door;

          if (id(update_start_millis) == 0 && id(display_update_pending)) {
            id(update_start_millis) = now_ms;
            id(sensor_retry_count) = 0;
            id(last_retry_millis) = 0;
          }

          // Retry fetching sensor data if missing and we haven't exceeded retry limit
          const int max_retries = 3;  // Reduced from 5 to 3 retries to save power
          const uint32_t retry_interval_ms = 2000;  // Reduced from 3s to 2s between retries
          bool should_retry = false;

          if (!all_data_ready && id(sensor_retry_count) < max_retries) {
            if (id(last_retry_millis) == 0) {
              // First retry attempt
              should_retry = true;
            } else {
              uint32_t time_since_retry = (now_ms >= id(last_retry_millis)) ? (now_ms - id(last_retry_millis)) : (UINT32_MAX - id(last_retry_millis) + now_ms);
              if (time_since_retry >= retry_interval_ms) {
                should_retry = true;
              }
            }
          }

          if (should_retry) {
            id(retry_sensor_fetch).execute();
            return;  // Wait for next interval to check again
          }

          const uint32_t max_wait_ms = 12000;  // Reduced from 20s to 12s to sleep sooner
          uint32_t elapsed_ms = 0;
          bool timed_out = false;
          if (id(update_start_millis) != 0) {
            elapsed_ms = (now_ms >= id(update_start_millis)) ? (now_ms - id(update_start_millis)) : (UINT32_MAX - id(update_start_millis) + now_ms);
            timed_out = elapsed_ms >= max_wait_ms;
          }

          if (!id(initial_data_loaded)) {
            if (all_data_ready) {
              id(initial_data_loaded) = true;
              id(queue_display_refresh).execute();
              timed_out = true;  // proceed immediately
            } else if (!timed_out && id(sensor_retry_count) < max_retries) {
              return;  // Keep waiting and retrying
            } else {
              // Give up after retries/timeout - proceed with available data
              id(initial_data_loaded) = true;
              id(queue_display_refresh).execute();
              timed_out = true;
            }
          } else if (!all_data_ready && !timed_out && id(sensor_retry_count) < max_retries) {
            return;  // Keep retrying
          }

          // Prevent display updates between midnight and 7am to conserve power
          // Check this early so ESP goes right back to sleep during quiet hours
          auto current_time = id(ha_time).now();
          if (current_time.is_valid()) {
            int current_hour = current_time.hour;
            if (current_hour >= 0 && current_hour < 7) {
              id(display_update_pending) = false;
              id(cycle_update_done) = true;
              id(update_start_millis) = 0;
              id(sensor_retry_count) = 0;
              id(last_retry_millis) = 0;
              id(delayed_deep_sleep).execute();
              return;
            }
          }

          if (!id(display_update_pending) && !timed_out && id(cycle_update_done)) {
            return;
          }

          id(display_update_pending) = false;
          id(cycle_update_done) = true;
          // Boost CPU frequency only for display update (most power-intensive operation)
          setCpuFrequencyMhz(240);
          id(epaper_display).update();
          // Immediately reduce CPU frequency after display update
          setCpuFrequencyMhz(80);
          id(update_start_millis) = 0;
          id(sensor_retry_count) = 0;
          id(last_retry_millis) = 0;
          id(delayed_deep_sleep).execute();
          return;
  # Fallback: force display after 30 seconds even without all HA data (for initial boot)
  # This gives time for retries to complete
  - interval: 30s
    then:
      - if:
          condition:
            lambda: 'return !id(initial_data_loaded);'
          then:
            - lambda: |-
                // Force display after 30 seconds even without all HA data
                id(initial_data_loaded) = true;
                id(update_start_millis) = millis();
                id(sensor_retry_count) = 0;
                id(last_retry_millis) = 0;
                id(queue_display_refresh).execute();
text_sensor:
  - platform: homeassistant
    id: alarm_state
    entity_id: alarm_control_panel.147_alarm
    attribute: state
    on_value:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: garage_lock
    entity_id: lock.garage_lock
    attribute: state
  - platform: homeassistant
    id: garage_door
    entity_id: cover.garage_door_2
    attribute: state
    on_value:
      then:
        - if:
            condition:
              lambda: 'return !id(initial_data_loaded);'
            then:
              - lambda: |-
                  // If key sensors already have state, mark loaded and render
                  // Mark as ready if we have any key data
                  bool ready = id(lights_on).has_state() || id(indoor_temp).has_state() || id(current_power_usage).has_state() || id(guest_mode).has_state();
                  if (ready) {
                    id(initial_data_loaded) = true;
                  }
  - platform: homeassistant
    id: current_power_usage
    entity_id: sensor.147_123_1min
    on_value:
      then:
        - lambda: |-
            // Check for unavailable or empty values - don't overwrite last known good value
            if (x.empty() || x == "unavailable" || x == "unknown") {
              return;  // Skip processing unavailable values
            }

            float power_value = atof(x.c_str());

            // Only update last known value if we got a valid number (not 0.0 from failed parse)
            if (!isnan(power_value) && power_value >= 0.0f) {
              id(last_known_power) = power_value;
            } else {
              return;  // Invalid value, don't process
            }

            auto now = id(ha_time).now();
            int current_day = -1;
            if (now.is_valid()) {
              current_day = now.day_of_year;
            }

            if (!id(power_stats_initialized)) {
              id(power_stats)[0] = power_value;
              id(power_stats)[1] = power_value;
              id(power_stats_day) = current_day;
              id(power_stats_initialized) = true;
              id(daily_power_max).publish_state(power_value);
              id(daily_power_min).publish_state(power_value);
              if (now.is_valid()) {
                id(peak_power_time) = now.strftime("%I:%M %p");
              }
            } else {
              // Check if it's a new day
              if (current_day >= 0 && id(power_stats_day) != current_day) {
                id(power_stats)[0] = power_value;
                id(power_stats)[1] = power_value;
                id(power_stats_day) = current_day;
                id(daily_power_max).publish_state(power_value);
                id(daily_power_min).publish_state(power_value);
                if (now.is_valid()) {
                  id(peak_power_time) = now.strftime("%I:%M %p");
                }
              } else {
                if (power_value > id(power_stats)[0] || id(power_stats)[0] <= 0.0f) {
                  id(power_stats)[0] = power_value;
                  id(daily_power_max).publish_state(power_value);
                  if (now.is_valid()) {
                    id(peak_power_time) = now.strftime("%I:%M %p");
                  }
                }

                if (id(power_stats)[1] < 0.0f || power_value < id(power_stats)[1]) {
                  id(power_stats)[1] = power_value;
                  id(daily_power_min).publish_state(power_value);
                }
              }
            }

            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: estimated_monthly_cost
    entity_id: sensor.estimated_monthly_cost
    on_value:
      then:
        - lambda: |-
            // Check for unavailable or empty values - don't overwrite last known good value
            if (x.empty() || x == "unavailable" || x == "unknown") {
              return;  // Skip processing unavailable values
            }

            float cost_value = atof(x.c_str());

            // Only update last known value if we got a valid number
            if (!isnan(cost_value) && cost_value >= 0.0f) {
              id(last_known_cost) = cost_value;
            }

            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: next_calendar_event_time
    entity_id: sensor.next_calendar_event_time
    on_value:
      then:
        - lambda: |-
            // Check for unavailable or empty values - don't overwrite last known good value
            if (!x.empty() && x != "unavailable" && x != "unknown") {
              id(last_known_event_time) = x;
            }

            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: next_calendar_event_name
    entity_id: sensor.next_calendar_event_name
    on_value:
      then:
        - lambda: |-
            // Check for unavailable or empty values - don't overwrite last known good value
            if (!x.empty() && x != "unavailable" && x != "unknown") {
              id(last_known_event_name) = x;
            }

            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }
  - platform: homeassistant
    id: special_message_banner
    entity_id: input_text.trmnl_banner
    on_value:
      then:
        - lambda: |-
            if (id(initial_data_loaded)) {
              id(queue_display_refresh).execute();
            }

display:
  - platform: waveshare_epaper
    id: epaper_display
    model: 7.50inv2
    cs_pin: GPIO44
    dc_pin: GPIO10
    reset_pin: GPIO38
    busy_pin:
      number: GPIO4
      inverted: true
    update_interval: never  # Updates are controlled by interval timer when all data is ready
    lambda: |-
      // Screen dimension constants
      const int scr_w = 800;
      const int scr_h = 480;
      const int center_x = scr_w / 2;

      // Cache time object once at start - reuse throughout lambda
      auto now = id(ha_time).now();
      id(last_update_time) = now.strftime("%I:%M %p");

      if (!id(initial_data_loaded)) {
        it.printf(center_x, scr_h / 2, id(big_font), TextAlign::CENTER, "Loading...");
        return;
      }

      // Battery glyph is already calculated in sensor callback, just use it
      float level = id(battery_level).state;
      int current_y = 40; // Start from top with padding

      // Check if debug mode is enabled (default to false if no state available)
      bool debug_mode_enabled = id(debug_mode).has_state() && id(debug_mode).state;

      // Cache sensor state checks once - reuse throughout lambda
      bool has_guest_mode = id(guest_mode).has_state();
      bool guest_mode_state = has_guest_mode && id(guest_mode).state;
      bool has_alarm_state = id(alarm_state).has_state();
      bool has_lights = id(lights_on).has_state();
      float lights_count = NAN;
      if (has_lights && id(lights_on).state == id(lights_on).state) {  // Check for NAN
        lights_count = id(lights_on).state;
      }
      if (isnan(lights_count) && !isnan(id(last_known_lights))) {
        lights_count = id(last_known_lights);
      }

      // Cache door states once - reuse for both status text and icon display
      bool has_garage_door = id(garage_door).has_state();
      bool garage_door_open = has_garage_door && strcmp(id(garage_door).state.c_str(), "open") == 0;
      bool has_entry_door = id(entry_door).has_state();
      bool entry_door_open = has_entry_door && id(entry_door).state;
      bool has_upstairs_patio = id(upstairs_patio_door).has_state();
      bool upstairs_patio_open = has_upstairs_patio && id(upstairs_patio_door).state;
      bool has_inlaw_door = id(inlaw_door).has_state();
      bool inlaw_door_open = has_inlaw_door && id(inlaw_door).state;
      // Use same sensor for both inlaw door and patio (they're the same entity)
      bool inlaw_patio_open = inlaw_door_open;
      bool has_garage_entry = id(garage_entry_door).has_state();
      bool garage_entry_open = has_garage_entry && id(garage_entry_door).state;
      bool has_garage_lock = id(garage_lock).has_state();
      bool garage_unlocked = has_garage_lock && strcmp(id(garage_lock).state.c_str(), "unlocked") == 0;

      // Cache plant states - check if moisture is less than 5
      bool has_plant1 = id(plant1_moisture).has_state();
      bool plant1_dry_state = has_plant1 && !isnan(id(plant1_moisture).state) && id(plant1_moisture).state < 5.0f;
      bool has_plant2 = id(plant2_moisture).has_state();
      bool plant2_dry_state = has_plant2 && !isnan(id(plant2_moisture).state) && id(plant2_moisture).state < 5.0f;
      bool has_plant3 = id(plant3_moisture).has_state();
      bool plant3_dry_state = has_plant3 && !isnan(id(plant3_moisture).state) && id(plant3_moisture).state < 5.0f;
      bool has_plant4 = id(plant4_moisture).has_state();
      bool plant4_dry_state = has_plant4 && !isnan(id(plant4_moisture).state) && id(plant4_moisture).state < 5.0f;
      bool any_plant_dry = plant1_dry_state || plant2_dry_state || plant3_dry_state || plant4_dry_state;

      // --- Row 1: Top row - Special message banner or date (large font) ---
      std::string banner_text;
      if (debug_mode_enabled) {
        // Debug mode: show test string with special characters
        banner_text = "DEBUG!@#$%^&*()_+-=[]{};':\",./<>?`~";
      } else if (id(special_message_banner).has_state() && !id(special_message_banner).state.empty()) {
        banner_text = id(special_message_banner).state;
      } else {
        // Format date like "Tuesday • December 2 • 2025"
        char date_buf[64];
        snprintf(date_buf, sizeof(date_buf), "%s • %s %d • %d",
                 now.strftime("%A").c_str(),
                 now.strftime("%B").c_str(),
                 now.day_of_month,
                 now.year);
        banner_text = date_buf;
      }
      it.printf(center_x, current_y, id(date_font), TextAlign::TOP_CENTER, "%s", banner_text.c_str());
      current_y += 90; // Move down for next row

      // --- Row 2: Next calendar event (medium font) ---
      // Note: Using filtered sensors from Home Assistant that exclude all-day events
      std::string event_text;
      std::string event_name;
      std::string event_time;

      // Get current values or fall back to last known values
      if (id(next_calendar_event_name).has_state()) {
        event_name = id(next_calendar_event_name).state;
        // If unavailable, use last known value
        if (event_name.empty() || event_name == "unavailable" || event_name == "unknown") {
          event_name = id(last_known_event_name);
        }
      } else {
        event_name = id(last_known_event_name);
      }

      if (id(next_calendar_event_time).has_state()) {
        event_time = id(next_calendar_event_time).state;
        // If unavailable, use last known value
        if (event_time.empty() || event_time == "unavailable" || event_time == "unknown") {
          event_time = id(last_known_event_time);
        }
      } else {
        event_time = id(last_known_event_time);
      }

      // Only display if we have valid event data
      if (!event_name.empty() && !event_time.empty() &&
          event_name != "unavailable" && event_time != "unavailable") {
        // Truncate event name if longer than "Property taxes due - 1st installment" (36 chars)
        const int max_event_name_length = 32;
        std::string display_event_name = event_name;
        if (display_event_name.length() > max_event_name_length) {
          display_event_name = display_event_name.substr(0, max_event_name_length);
        }
        // Format like "Dentist • 12pm-1pm today"
        char event_buf[128];
        snprintf(event_buf, sizeof(event_buf), "%s • %s", display_event_name.c_str(), event_time.c_str());
        event_text = event_buf;
      }
      if (!event_text.empty()) {
        it.printf(center_x, current_y, id(mid_font), TextAlign::TOP_CENTER, "%s", event_text.c_str());
      }
      current_y += 70; // Move down for next row (increased spacing)

      // --- Row 3: Open doors/windows and lights status (status font) ---
      std::string status_text;

      if (debug_mode_enabled) {
        // Debug mode: show test values
        status_text = "test door is open • lights: 100";
      } else {
        // Collect open doors/windows using cached door states
        std::vector<std::string> open_items;

        if (garage_door_open) {
          open_items.push_back("Garage");
        }
        if (entry_door_open) {
          open_items.push_back("Entry");
        }
        if (upstairs_patio_open) {
          open_items.push_back("Patio");
        }
        if (inlaw_door_open) {
          open_items.push_back("In-law");
        }
        if (inlaw_patio_open) {
          open_items.push_back("In-law Patio");
        }
        if (garage_entry_open) {
          open_items.push_back("Garage Entry");
        }

        // Add garage unlocked warning using cached state
        if (garage_unlocked) {
          open_items.push_back("Garage Unlocked");
        }

        // Build status text
        if (!open_items.empty()) {
          status_text = "Open: " + open_items[0];
          for (size_t i = 1; i < open_items.size(); i++) {
            status_text += ", " + open_items[i];
          }
        } else {
          status_text = "All doors and windows closed";
        }

        // Add lights status using cached lights_count

        if (!isnan(lights_count)) {
          if (lights_count == 0.0f) {
            status_text += " • All lights off";
          } else {
            char lights_buf[32];
            snprintf(lights_buf, sizeof(lights_buf), " • Lights on: %.0f", lights_count);
            status_text += lights_buf;
          }
        } else {
          status_text += " • Lights on: --";
        }
      }

      it.printf(center_x, current_y, id(status_font), TextAlign::TOP_CENTER, "%s", status_text.c_str());
      current_y += 70; // Move down for next row (increased spacing)

      // --- Row 4: Power consumption and monthly estimate (power font) ---
      std::string power_text;

      // Get current power value or fall back to last known value
      float power_value = NAN;
      if (id(current_power_usage).has_state()) {
        std::string power_str = id(current_power_usage).state;
        if (!power_str.empty() && power_str != "unavailable" && power_str != "unknown") {
          power_value = atof(power_str.c_str());
        }
      }
      // Fall back to last known value if current is unavailable
      if (isnan(power_value) && !isnan(id(last_known_power))) {
        power_value = id(last_known_power);
      }

      // Get current cost value or fall back to last known value
      float cost_value = NAN;
      if (id(estimated_monthly_cost).has_state()) {
        std::string cost_str = id(estimated_monthly_cost).state;
        if (!cost_str.empty() && cost_str != "unavailable" && cost_str != "unknown") {
          cost_value = atof(cost_str.c_str());
        }
      }
      // Fall back to last known value if current is unavailable
      if (isnan(cost_value) && !isnan(id(last_known_cost))) {
        cost_value = id(last_known_cost);
      }

      if (!isnan(power_value) && !isnan(cost_value)) {
        float rounded_cost = roundf(cost_value * 100.0f) / 100.0f;
        char power_buf[64];
        if (power_value == 0.0f) {
          snprintf(power_buf, sizeof(power_buf), "$%.2f", rounded_cost);
        } else {
          snprintf(power_buf, sizeof(power_buf), "%.0f W • $%.2f", power_value, rounded_cost);
        }
        power_text = power_buf;
      } else if (!isnan(power_value)) {
        if (power_value == 0.0f) {
          power_text = "";
        } else {
          char power_buf[32];
          snprintf(power_buf, sizeof(power_buf), "%.0f W", power_value);
          power_text = power_buf;
        }
      } else {
        power_text = "Waiting for power data...";
      }

      it.printf(center_x, current_y - 10, id(power_font), TextAlign::TOP_CENTER, "%s", power_text.c_str());
      current_y += 50; // Move down for next row (reduced by 10 pixels)

      // --- Row 5: Icons for guest mode, packages, trash night, alarm, lights, doors (medium font/icons) ---
      // Count how many icons will be displayed
      int icon_count = 0;
      bool show_guest;
      bool show_package;
      bool show_trash;
      bool show_alarm;
      bool show_lights;
      bool show_door;
      bool show_plant;

      // Check if it's Wednesday (trash night)
      bool is_wednesday = false;
      if (now.is_valid()) {
        std::string day_name = now.strftime("%A");
        // Convert to lowercase for comparison
        std::string day_lower = day_name;
        for (char &c : day_lower) {
          c = tolower(c);
        }
        is_wednesday = (day_lower == "wednesday");
      }

      if (debug_mode_enabled) {
        // Debug mode: show all icons
        show_guest = true;
        show_package = true;
        show_trash = true;
        show_alarm = true;
        show_lights = true;
        show_door = true;
        show_plant = true;
        icon_count = 7; // All 7 icons: guest, package, trash, alarm, lights, door, plant
      } else {
        // Normal mode: conditional display using cached sensor states
        // Guest mode icon - only show if guest_mode boolean is true
        show_guest = guest_mode_state;
        if (show_guest) {
          icon_count++;
        }

        show_package = id(package_detected);
        if (show_package) {
          icon_count++;
        }

        show_trash = is_wednesday;
        if (show_trash) {
          icon_count++;
        }

        // Alarm icon using cached state
        show_alarm = has_alarm_state;
        if (show_alarm) {
          icon_count++;
        }

        // Light bulb icon - show if at least 1 light is on using cached lights_count
        show_lights = !isnan(lights_count) && lights_count >= 1.0f;
        if (show_lights) {
          icon_count++;
        }

        // Open door icon - show if at least one door or window is open using cached door states
        show_door = garage_door_open || entry_door_open || upstairs_patio_open ||
                    inlaw_door_open || garage_entry_open || garage_unlocked;
        if (show_door) {
          icon_count++;
        }

        // Plant icon - show if any of the 4 plants are dry using cached plant states
        show_plant = any_plant_dry;
        if (show_plant) {
          icon_count++;
        }
      }

      // Calculate centered positions based on icon count
      // Increased spacing for larger icons (doubled size)
      int icon_spacing = 200; // Increased spacing for larger icons
      int total_width = (icon_count - 1) * icon_spacing;
      int start_x = center_x - (total_width / 2);
      int current_icon_x = start_x;
      int icon_y = current_y - 10; // Move icons up by 10 pixels

      // Guest mode icon - only show if guest_mode boolean is true
      if (show_guest) {
        it.printf(current_icon_x, icon_y + 52, id(guest_icon_font), TextAlign::CENTER, "\U0000e16b"); // weekend
        current_icon_x += icon_spacing;
      }

      // Package icon - only show if packages detected
      if (show_package) {
        it.printf(current_icon_x, icon_y + 52, id(package_icon_font), TextAlign::CENTER, "\U0000e3d1"); // inventory_2
        current_icon_x += icon_spacing;
      }

      // Trash night icon - show on Wednesdays
      if (show_trash) {
        it.printf(current_icon_x, icon_y + 52, id(trash_icon_font), TextAlign::CENTER, "\U0000ea4c"); // auto_delete
        current_icon_x += icon_spacing;
      }

      // Alarm status icon - lock for armed, lock-open for disarmed
      if (show_alarm) {
        const char *alarm_icon;
        if (debug_mode_enabled) {
          // Debug mode: show shield_lock icon (armed)
          alarm_icon = "\U0000e867";
        } else if (id(alarm_state).has_state()) {
          alarm_icon = (strcmp(id(alarm_state).state.c_str(), "armed_away") == 0 ||
                        strcmp(id(alarm_state).state.c_str(), "armed_home") == 0 ||
                        strcmp(id(alarm_state).state.c_str(), "armed_night") == 0 ||
                        strcmp(id(alarm_state).state.c_str(), "armed_vacation") == 0 ||
                        strcmp(id(alarm_state).state.c_str(), "armed_custom_bypass") == 0)
                        ? "\U0000e867" : "\U0000e898"; // shield_lock if armed, lock_open if disarmed
        } else {
          // Fallback: show lock_open icon if no state
          alarm_icon = "\U0000e898";
        }
        it.printf(current_icon_x, icon_y + 52, id(alarm_icon_font), TextAlign::CENTER, "%s", alarm_icon);
        current_icon_x += icon_spacing;
      }

      // Light bulb icon - show if at least 1 light is on
      if (show_lights) {
        it.printf(current_icon_x, icon_y + 52, id(alarm_icon_font), TextAlign::CENTER, "\U0000e0ef"); // lightbulb
        current_icon_x += icon_spacing;
      }

      // Open door icon - show if at least one door or window is open
      if (show_door) {
        it.printf(current_icon_x, icon_y + 52, id(alarm_icon_font), TextAlign::CENTER, "\U0000e875"); // door_open
        current_icon_x += icon_spacing;
      }

      // Plant icon - show if any plants are dry
      if (show_plant) {
        it.printf(current_icon_x, icon_y + 52, id(alarm_icon_font), TextAlign::CENTER, "\U0000e88a"); // potted_plant
        current_icon_x += icon_spacing;
      }

      current_y += 80; // Move down for next row

      // --- Row 6: Bottom row - Battery % (right) and last updated time (left) (tiny font) ---
      const int bottom_y = scr_h - 30; // Moved up by 10 pixels
      const int icon_offset = -4; // Icon glyphs need slight upward offset

      // Last updated time on left (moved right by 10 pixels)
      it.printf(30, bottom_y, id(tiny_font), TextAlign::BOTTOM_LEFT, "Last update: %s", id(last_update_time).c_str());

      // Battery percentage and icon on right (moved left by 20 pixels total: 10 + 5 + 5)
      it.printf(scr_w - 30, bottom_y, id(tiny_font), TextAlign::BOTTOM_RIGHT, "%.0f%%", level);
      it.printf(scr_w - 75, bottom_y + icon_offset, id(font_bat_icon), TextAlign::BOTTOM_RIGHT, "%s", id(battery_glyph).c_str());

      // CPU frequency reduction handled in interval lambda before sleep
